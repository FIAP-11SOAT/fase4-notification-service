terraform {
  backend "s3" {
    bucket = "notification-service-tfstate-268021560448"
    key    = "terraform.tfstate"
    region = "us-east-1"
  }
}

provider "aws" {
  region = "us-east-1"
}

data "aws_caller_identity" "current" {}

# DynamoDB

resource "aws_dynamodb_table" "notifications" {
  name         = "${var.project_name}-${var.environment}-notifications"
  billing_mode = "PAY_PER_REQUEST"
  hash_key     = "id"

  attribute {
    name = "id"
    type = "S"
  }

  point_in_time_recovery {
    enabled = true
  }

  server_side_encryption {
    enabled = true
  }

  tags = merge(var.tags, {
    Name = "${var.project_name}-${var.environment}-notifications"
  })
}

output "dynamodb_table_name" {
  value = aws_dynamodb_table.notifications.name
}

output "dynamodb_table_arn" {
  value = aws_dynamodb_table.notifications.arn
}

resource "aws_iam_policy" "dynamodb_access" {
  name = "dynamodb-access"

  policy = jsonencode({
    Version = "2012-10-17",
    Statement = [
      {
        Effect = "Allow",
        Action = [
          "dynamodb:GetItem",
          "dynamodb:PutItem",
          "dynamodb:UpdateItem",
          "dynamodb:Query",
          "dynamodb:Scan"
        ],
        Resource = aws_dynamodb_table.notifications.arn
      }
    ]
  })
}

# ECR Repository
resource "aws_ecr_repository" "main" {
  name                 = "notification-service-prod"
  image_tag_mutability = "MUTABLE"

  image_scanning_configuration {
    scan_on_push = true
  }

  encryption_configuration {
    encryption_type = "AES256"
  }

  tags = merge(var.tags, {
    Name = "notification-service-prod-ecr"
  })
}

# ECR Repository Policy
resource "aws_ecr_repository_policy" "main" {
  repository = aws_ecr_repository.main.name

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Sid    = "AllowPushPull"
        Effect = "Allow"
        Principal = {
          AWS = "*"
        }
        Action = [
          "ecr:GetDownloadUrlForLayer",
          "ecr:BatchGetImage",
          "ecr:BatchCheckLayerAvailability",
          "ecr:PutImage",
          "ecr:InitiateLayerUpload",
          "ecr:UploadLayerPart",
          "ecr:CompleteLayerUpload",
          "ecr:DescribeRepositories",
          "ecr:GetRepositoryPolicy",
          "ecr:ListImages",
          "ecr:DeleteRepository",
          "ecr:BatchDeleteImage",
          "ecr:SetRepositoryPolicy",
          "ecr:DeleteRepositoryPolicy"
        ]
      }
    ]
  })
}

# ECR Lifecycle Policy
resource "aws_ecr_lifecycle_policy" "main" {
  repository = aws_ecr_repository.main.name

  policy = jsonencode({
    rules = [
      {
        rulePriority = 1
        description  = "Keep last 10 images"
        selection = {
          tagStatus     = "tagged"
          tagPrefixList = ["v"]
          countType     = "imageCountMoreThan"
          countNumber   = 10
        }
        action = {
          type = "expire"
        }
      },
      {
        rulePriority = 2
        description  = "Delete untagged images older than 1 day"
        selection = {
          tagStatus   = "untagged"
          countType   = "sinceImagePushed"
          countUnit   = "days"
          countNumber = 1
        }
        action = {
          type = "expire"
        }
      }
    ]
  })
}

########################
# VPC + Subnet pública
########################
resource "aws_vpc" "main" {
  cidr_block           = "10.0.0.0/16"
  enable_dns_support   = true
  enable_dns_hostnames = true

  tags = { Name = "demo-vpc" }
}

resource "aws_internet_gateway" "igw" {
  vpc_id = aws_vpc.main.id

  tags = { Name = "demo-igw" }
}

resource "aws_subnet" "public" {
  vpc_id                  = aws_vpc.main.id
  cidr_block              = "10.0.1.0/24"
  availability_zone       = "us-east-1a"
  map_public_ip_on_launch = true

  tags = { Name = "demo-public-subnet" }
}

resource "aws_route_table" "public" {
  vpc_id = aws_vpc.main.id

  route {
    cidr_block = "0.0.0.0/0"
    gateway_id = aws_internet_gateway.igw.id
  }

  tags = { Name = "demo-public-rt" }
}

resource "aws_route_table_association" "public_assoc" {
  subnet_id      = aws_subnet.public.id
  route_table_id = aws_route_table.public.id
}

########################
# Security Group da EC2
########################
resource "aws_security_group" "notification_sg" {
  name        = "notification-service-sg"
  description = "SG for notification-service EC2"
  vpc_id      = aws_vpc.main.id

  # SSH só do seu IP – ajuste para o seu /32
  ingress {
    from_port   = 22
    to_port     = 22
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  # tudo de saída
  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }

  tags = { Name = "notification-service-sg" }
}

########################
# IAM Role da EC2
########################
data "aws_iam_policy_document" "notification_service_trust" {
  statement {
    actions = ["sts:AssumeRole"]

    principals {
      type        = "Service"
      identifiers = ["ec2.amazonaws.com"]
    }
  }
}

resource "aws_iam_role" "notification_service_role" {
  name               = "notification-service-ec2-role"
  assume_role_policy = data.aws_iam_policy_document.notification_service_trust.json
}

# Policy para CONSUMIR a fila
data "aws_iam_policy_document" "notification_consumer" {
  statement {
    actions = [
      "sqs:ReceiveMessage",
      "sqs:DeleteMessage",
      "sqs:ChangeMessageVisibility",
      "sqs:GetQueueAttributes",
    ]

    resources = [
      aws_sqs_queue.notification_queue.arn
    ]
  }
}

resource "aws_iam_policy" "notification_consumer" {
  name        = "notification-service-consume-notification-queue"
  description = "Allow notification-service to consume messages from notification-queue"
  policy      = data.aws_iam_policy_document.notification_consumer.json
}

resource "aws_iam_role_policy_attachment" "attach_notification_consumer" {
  role       = aws_iam_role.notification_service_role.name
  policy_arn = aws_iam_policy.notification_consumer.arn
}

resource "aws_iam_instance_profile" "notification_service_profile" {
  name = "notification-service-ec2-profile"
  role = aws_iam_role.notification_service_role.name
}

########################
# EC2 do notification-service
########################
resource "aws_instance" "notification_service" {
  ami                    = "ami-0c02fb55956c7d316" # Amazon Linux 2 em us-east-1 – verifique se ainda é válida
  instance_type          = "t3.micro"
  subnet_id              = aws_subnet.public.id
  vpc_security_group_ids = [aws_security_group.notification_sg.id]

  iam_instance_profile        = aws_iam_instance_profile.notification_service_profile.name
  associate_public_ip_address = true

  user_data = templatefile("${path.module}/user_data.sh", {
    queue_url  = aws_sqs_queue.notification_queue.id
    account_id = data.aws_caller_identity.current.account_id
  })

  tags = {
    Name = "notification-service-ec2"
  }
}

# Amazon Simple Email Service

# Verificação de Email Individual
resource "aws_ses_email_identity" "from" {
  email = "mandacosta94@gmail.com"
}

# IAM User para SMTP
resource "aws_iam_user" "ses_smtp_user" {
  name = "ses-smtp-user"
}

# Access Key SMTP
resource "aws_iam_access_key" "ses_smtp" {
  user = aws_iam_user.ses_smtp_user.name
}

# Política IAM mínima para envio
resource "aws_iam_policy" "ses_send" {
  name = "SES-SendEmail-Policy"
  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [{
      Effect = "Allow"
      Action = [
        "ses:SendEmail",
        "ses:SendRawEmail"
      ]
      Resource = "*"
    }]
  })
}

resource "aws_iam_user_policy_attachment" "ses_policy" {
  user       = aws_iam_user.ses_smtp_user.name
  policy_arn = aws_iam_policy.ses_send.arn
}

resource "aws_secretsmanager_secret" "smtp_credentials_ses" {
  name                    = "smtp-credentials-ses"
  recovery_window_in_days = 0
}

resource "aws_secretsmanager_secret_version" "smtp_credentials_version" {
  secret_id = aws_secretsmanager_secret.smtp_credentials_ses.id

  secret_string = jsonencode({
    username = aws_iam_access_key.ses_smtp.id
    password = aws_iam_access_key.ses_smtp.ses_smtp_password_v4
  })
}

output "smtp_username" {
  value = aws_iam_access_key.ses_smtp.id
}

output "smtp_password" {
  description = "Senha SMTP SES"
  value       = aws_iam_access_key.ses_smtp.ses_smtp_password_v4
  sensitive   = true
}

resource "aws_sqs_queue" "notification_queue" {
  name = "notification-queue"

  visibility_timeout_seconds = 30
  message_retention_seconds  = 345600 # 4 dias
  max_message_size           = 262144 # 256 KB
  delay_seconds              = 0
  receive_wait_time_seconds  = 5

  tags = {
    Service     = "notification-service"
    Environment = "prod"
  }
}

output "notification_queue_url" {
  value = aws_sqs_queue.notification_queue.url
}

output "notification_queue_arn" {
  value = aws_sqs_queue.notification_queue.arn
}

resource "aws_iam_policy" "producers_send_to_notification_queue" {
  name        = "producers-send-to-notification-queue"
  description = "Allow producer services to send messages to notification-queue"

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Sid    = "AllowSendToNotificationQueue"
        Effect = "Allow"
        Action = [
          "sqs:SendMessage",
          "sqs:GetQueueUrl"
        ]
        Resource = aws_sqs_queue.notification_queue.arn
      }
    ]
  })
}

output "notification_queue_producer_policy_arn" {
  value       = aws_iam_policy.producers_send_to_notification_queue.arn
  description = "ARN da policy que permite enviar mensagens para a fila"
}

variable "project_name" {
  description = "Name of the project"
  type        = string
  default     = "notification-service"
}

variable "environment" {
  description = "Environment name"
  type        = string
  default     = "production"
}

variable "aws_region" {
  description = "AWS region"
  type        = string
  default     = "us-east-1"
}

variable "tags" {
  description = "A map of tags to assign to the resource"
  type        = map(string)
  default     = {}
}